<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Brewing & Fermentation Calculator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
        /* CSS Variables for Light Theme */
        :root {
            --bg-color: #f9f9f9;
            --card-bg: #fff;
            --text-color: #2c3e50;
            --border-color: #ccc;
            --input-bg: #fff;
            --button-bg: #3498db;
            --button-text: #fff;
            --secondary-text: #7f8c8d;
            --gradient-bar: linear-gradient(to right, #2ecc71, #f39c12, #e74c3c);
            --indicator-color: #2c3e50;
            --tip-bg: rgba(52, 152, 219, 0.1);
            --tip-border: rgba(52, 152, 219, 0.2);
            --h1-light-color: #2563eb; /* Equivalent to Tailwind blue-600 */
        }

        /* CSS Variables for Dark Theme (matching the image) */
        [data-theme="dark"] {
            --bg-color: #1c2a38; /* Dark blue-grey background */
            --card-bg: #2a3d4f; /* Slightly lighter dark blue-grey for cards */
            --text-color: #e0e0e0; /* Light grey text */
            --border-color: #4a6177; /* Darker blue-grey border */
            --input-bg: #3a5068; /* Darker blue-grey for inputs */
            --button-bg: #4a90e2; /* Blue button */
            --button-text: #fff; /* White button text */
            --secondary-text: #b0b0b0; /* Lighter grey secondary text */
            --gradient-bar: linear-gradient(to right, #27ae60, #e67e22, #c0392b); /* Green, orange, red gradient */
            --indicator-color: #e0e0e0; /* Light grey indicator */
            --tip-bg: rgba(74, 144, 226, 0.1); /* Blue tint for tips */
            --tip-border: rgba(74, 144, 226, 0.2);
            --h1-dark-color: #60a5fa; /* Equivalent to Tailwind blue-400 */
        }

        /* General Body Styling */
        body {
            font-family: Arial, sans-serif;
            padding: 15px; /* Reduced padding */
            max-width: 750px;
            margin: auto;
            background: var(--bg-color);
            padding-bottom: 80px; /* Reduced padding */
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition for theme change */
            font-size: 0.95em; /* Slightly smaller base font size */
        }

        /* Main Heading */
        h1 {
            color: var(--h1-light-color); /* Use the specific light mode blue */
            text-align: center;
            margin-bottom: 25px; /* Reduced margin */
            font-size: 1.8em; /* Further reduced font size for H1 */
            font-weight: bold; /* Ensure bold font */
        }

        /* Dark mode specific color for h1 */
        [data-theme="dark"] h1 {
            color: var(--h1-dark-color); /* Use the specific dark mode blue */
        }

        /* Theme Toggle Button */
        .theme-toggle {
            position: fixed;
            top: 15px; /* Adjusted position */
            right: 15px; /* Adjusted position */
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 50px;
            padding: 8px 12px; /* Slightly smaller padding */
            cursor: pointer;
            font-size: 13px; /* Slightly smaller font size */
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .theme-toggle:hover {
            opacity: 0.8;
        }

        /* Section Headings (now acting as separators) */
        h2 {
            color: var(--text-color);
            margin-top: 30px; /* Reduced space above to act as a separator */
            margin-bottom: 12px; /* Reduced margin */
            font-size: 1.3em; /* Slightly smaller font size */
        }

        /* Labels, Inputs, Selects */
        label, input, select {
            display: block;
            margin-top: 8px; /* Reduced margin */
            color: var(--text-color);
        }

        /* Updated input styling to include text type and ensure consistent color */
        input[type="number"], input[type="text"], select {
            width: 100%;
            padding: 6px; /* Reduced padding */
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-color); /* Explicitly set text color */
            font-size: 0.9em; /* Slightly smaller font size */
        }

        /* Buttons */
        button {
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            padding: 8px 15px; /* Reduced padding */
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            transition: opacity 0.3s ease;
            font-size: 0.9em; /* Slightly smaller font size */
        }

        button:hover {
            opacity: 0.8;
        }

        /* Result Display */
        .result {
            margin-top: 15px; /* Reduced margin */
            padding: 8px; /* Reduced padding */
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-color);
            font-size: 0.9em; /* Slightly smaller font size */
        }

        .sweetness { color: #8e44ad; font-weight: bold; } /* Specific color for sweetness text */

        /* Sweetness Bar */
        .sweetness-bar-container {
            width: 100%;
            height: 18px; /* Slightly smaller height */
            background: var(--gradient-bar);
            border-radius: 9px; /* Adjusted border-radius */
            margin: 6px 0; /* Reduced margin */
            position: relative;
            border: 1px solid var(--border-color);
        }

        .sweetness-indicator {
            position: absolute;
            top: -1px; /* Adjusted position */
            width: 3px; /* Slightly smaller width */
            height: 20px; /* Slightly smaller height */
            background: var(--indicator-color);
            border-radius: 2px;
            transition: left 0.3s ease;
        }

        .sweetness-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px; /* Slightly smaller font size */
            color: var(--secondary-text);
            margin-top: 2px;
        }

        /* Status and Progress Text */
        .status, .progress { font-weight: bold; padding: 4px 0; } /* Reduced padding */
        .complete { color: #27ae60; } /* Green for complete */
        .nearly { color: #e67e22; } /* Orange for nearly complete */
        .active { color: #e74c3c; } /* Red for active */

        /* Volume Input Group (for side-by-side input and select) */
        .volume-input-group {
            display: flex;
            gap: 8px; /* Reduced gap */
            align-items: flex-end;
        }

        .volume-input-group input {
            flex: 2;
        }

        .volume-input-group select {
            flex: 1;
        }

        /* Unit Conversion Notes */
        .unit-note {
            font-size: 11px; /* Slightly smaller font size */
            color: var(--secondary-text);
            margin-top: 4px; /* Reduced margin */
        }

        /* Canvas for Charts */
        canvas {
            margin-top: 15px; /* Reduced margin */
            background: var(--card-bg);
            border-radius: 4px;
            padding: 8px; /* Reduced padding */
        }

        /* Individual Calculator Sections */
        .calculator-section {
            background: var(--card-bg);
            padding: 15px; /* Reduced padding */
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 25px; /* Reduced margin */
        }

        /* Wort Correction Factor Container (already existed, similar styling) */
        .wcf-container {
            background: var(--card-bg); /* Use card-bg for consistency */
            padding: 15px; /* Reduced padding */
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin: 15px 0; /* Reduced margin */
        }

        .wcf-label {
            display: block;
            font-weight: bold;
            font-size: 13px; /* Slightly smaller font size */
            margin-bottom: 6px; /* Reduced margin */
            color: var(--text-color);
        }

        .wcf-description {
            font-size: 12px; /* Slightly smaller font size */
            color: var(--text-color);
            line-height: 1.4; /* Adjusted line height */
            margin-bottom: 10px; /* Reduced margin */
        }

        .wcf-tip {
            background: var(--tip-bg);
            border: 1px solid var(--tip-border);
            border-radius: 6px;
            padding: 10px; /* Reduced padding */
            margin-top: 10px; /* Reduced margin */
            font-size: 11px; /* Slightly smaller font size */
            color: var(--secondary-text);
        }

        .tip-icon {
            color: var(--button-bg);
            margin-right: 5px; /* Reduced margin */
        }

        .highlight {
            color: var(--button-bg);
            font-weight: 500;
        }
    </style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<button class="theme-toggle" onclick="toggleTheme()">🌙 Dark Mode</button>

<h1>Brewing & Fermentation Calculator</h1>

<h2>Refractometer ABV/Brix Calculator</h2>
<div class="calculator-section">
    <div class="wcf-container">
        <label for="og_brix">Original Brix (WRI):</label>
        <input id="og_brix" step="0.01" type="number" value="18.0"/>
        <label for="fg_brix">Current Brix (WRI):</label>
        <input id="fg_brix" step="0.01" type="number" value="5.0"/>
        <label for="wcf" class="wcf-label">Wort Correction Factor</label>
        <div class="wcf-description">
            Fine-tune this factor using a <span class="highlight">completed bone dry batch</span> where you know the exact sugar additions or tested with a Hydrometer.
            Adjust until the calculated ABV matches your expected result from sugar input.
            The default (1.038) works for most setups, but calibrating ensures accuracy for your specific equipment and process.
        </div>
        <div class="wcf-tip">
            <span class="tip-icon">💡</span>
            <strong>Pro Tip:</strong> Use the Simple Sugar to ABV Estimator below to verify your expected ABV from total sugar and volume.
        </div>
        <input id="wcf" step="0.001" type="number" value="1.038"/>
    </div>
    <label for="volume_input">Volume for Calorie Calculation:</label>
    <div class="volume-input-group">
        <input id="volume_input" step="0.01" type="number" value="500"/>
        <select id="volume_unit">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</option>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quart</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter">Liter</option>
        </select>
    </div>
    <div class="unit-note" id="volume_note">500 mL = 16.91 US fl oz = 17.60 UK fl oz</div>
    <button onclick="calculateRefractometerAndEnableUpdates()">Calculate</button>
    <div class="result" id="output"></div>
    <!-- Removed <canvas id="abvChartRefractometer" width="600" height="300"></canvas> -->
</div>

<h2>Traditional Hydrometer (SG) Calculator</h2>
<div class="calculator-section">
    <label for="og_sg">Original Gravity (OG):</label>
    <input id="og_sg" step="0.001" type="number" value="1.0713"/>
    <label for="fg_sg">Final Gravity (FG):</label>
    <input id="fg_sg" step="0.001" type="number" value="0.9985"/>
    <label for="volume_input_sg">Volume for Calorie Calculation:</label>
    <div class="volume-input-group">
        <input id="volume_input_sg" step="0.01" type="number" value="500"/>
        <select id="volume_unit_sg">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</option>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quart</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter">Liter</option>
        </select>
    </div>
    <div class="unit-note" id="volume_note_sg">500 mL = 16.91 US fl oz = 17.60 UK fl oz</div>
    <button onclick="calculateHydrometerAndEnableUpdates()">Calculate from SG</button>
    <div class="result" id="sg_output"></div>
    <canvas id="abvChartHydrometer" width="600" height="300"></canvas>

    <h3>SG Readings Over Time</h3>
    <div id="sg_readings_container">
        <!-- Dynamic readings will be added here -->
    </div>
    <button onclick="addSgReadingField()">Add New Reading</button>
</div>

<h2>Simple Sugar to ABV Estimator</h2>
<div class="calculator-section">
    <label for="sugar_amount">Total Sugar Used:</label>
    <div class="volume-input-group">
        <input id="sugar_amount" step="0.01" type="number" value="4018"/>
        <select id="sugar_unit">
            <option value="grams" selected>Grams</option>
            <option value="kg">Kilograms</option>
            <option value="lbs">Pounds (lbs)</option>
            <option value="oz">Ounces (oz)</option>
            <option value="us_cups">US Cups</option>
            <option value="uk_cups">UK Cups</option>
        </select>
    </div>
    <div class="unit-note" id="sugar_note">3565 g = 3.57 kg = 7.86 lbs = 125.8 oz</div>
    <label for="volume_liters">Total Liquid Volume:</label>
    <div class="volume-input-group">
        <input id="volume_liters" step="0.01" type="number" value="25"/>
        <select id="batch_volume_unit">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</option>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quart</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter" selected>Liter</option>
        </select>
    </div>
    <div class="unit-note" id="batch_volume_note">25 L = 6.60 US gal = 5.50 UK gal</div>
    <label for="conversion_factor">Sugar per 1% ABV (g/L):</label>
    <input id="conversion_factor" step="0.01" type="number" value="16.83"/>
    <button onclick="calculateSugarABVAndEnableUpdates()">Estimate ABV</button>
    <div class="result" id="sugar_abv_output"></div>
</div>

<h2>Target ABV to Sugar Requirement</h2>
<div class="calculator-section">
    <label for="target_abv">Desired ABV (%):</label>
    <input id="target_abv" step="0.01" type="number" value="9.55"/>
    <label for="target_volume">Batch Volume:</label>
    <div class="volume-input-group">
        <input id="target_volume" step="0.01" type="number" value="25"/>
        <select id="target_volume_unit">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</option>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quart</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter" selected>Liter</option>
        </select>
    </div>
    <div class="unit-note" id="target_volume_note">25 L = 6.60 US gal = 5.50 UK gal</div>
    <label for="target_factor">Sugar per 1% ABV (g/L):</label>
    <input id="target_factor" step="0.01" type="number" value="16.83"/>
    <button onclick="calculateRequiredSugarAndEnableUpdates()">Calculate Required Sugar</button>
    <div class="result" id="required_sugar_output"></div>
</div>

<h2>Priming Sugar Calculator</h2>
<div class="calculator-section">
    <label for="prime_volume">Batch Volume:</label>
    <div class="volume-input-group">
        <input id="prime_volume" step="0.01" type="number" value="500"/>
        <select id="prime_volume_unit">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</option>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quarts</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</loption>
            <option value="liter">Liter</option>
        </select>
    </div>
    <div class="unit-note" id="prime_volume_note">500 mL = 16.91 US fl oz = 17.60 UK fl oz</div>
    <label for="co2_volumes">Desired CO2 Volumes:</label>
    <input id="co2_volumes" step="0.1" type="number" value="2.5"/>
    <label for="current_temp">Current Temperature (°C):</label>
    <input id="current_temp" step="0.1" type="number" value="20"/>
    <label for="sugar_type">Sugar Type:</label>
    <select id="sugar_type">
        <option value="table">Table Sugar (Sucrose)</option>
        <option value="corn">Corn Sugar (Dextrose)</option>
        <option value="dme">Dry Malt Extract</option>
        <option value="honey">Honey</option>
    </select>
    <button onclick="calculatePrimingSugarAndEnableUpdates()">Calculate Priming Sugar</button>
    <div class="result" id="priming_output"></div>
</div>

<h2>Dilution Calculator</h2>
<div class="calculator-section">
    <label for="current_abv">Current ABV (%):</label>
    <input id="current_abv" step="0.01" type="number" value="60"/>
    <label for="current_volume">Current Volume:</label>
    <div class="volume-input-group">
        <input id="current_volume" step="0.01" type="number" value="1"/>
        <select id="current_volume_unit">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</soption>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quart</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter" selected>Liter</option>
        </select>
    </div>
    <div class="unit-note" id="current_volume_note">20 L = 5.28 US gal = 4.40 UK gal</div>
    <label for="target_abv_dilution">Target ABV (%):</label>
    <input id="target_abv_dilution" step="0.01" type="number" value="40"/>

    <label for="dilution_calorie_volume_input">Volume for Kcal Calculation:</label>
    <div class="volume-input-group">
        <input id="dilution_calorie_volume_input" step="0.01" type="number" value="100"/>
        <select id="dilution_calorie_volume_unit">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</soption>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quarts</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter">Liter</option>
        </select>
    </div>
    <div class="unit-note" id="dilution_calorie_note">100 mL = 3.38 US fl oz = 3.52 UK fl oz</div>

    <button onclick="calculateDilutionAndEnableUpdates()">Calculate Water Needed</button>
    <div class="result" id="dilution_output"></div>
</div>

<h2>Blending Calculator</h2>
<div class="calculator-section">
    <label for="batch1_abv">Batch 1 ABV (%):</label>
    <input id="batch1_abv" step="0.01" type="number" value="40"/>
    <label for="batch1_volume">Batch 1 Volume:</label>
    <div class="volume-input-group">
        <input id="batch1_volume" step="0.01" type="number" value="300"/>
        <select id="batch1_volume_unit">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</option>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quarts</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter">Liter</option>
        </select>
    </div>
    <div class="unit-note" id="batch1_volume_note">15 L = 3.96 US gal = 3.30 UK gal</div>
    <label for="batch2_abv">Batch 2 ABV (%):</label>
    <input id="batch2_abv" step="0.01" type="number" value="9.55"/>
    <label for="batch2_volume">Batch 2 Volume:</label>
    <div class="volume-input-group">
        <input id="batch2_volume" step="0.01" type="number" value="700"/>
        <select id="batch2_volume_unit">
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</option>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quarts</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter">Liter</option>
        </select>
    </div>
    <div class="unit-note" id="batch2_volume_note">10 L = 2.64 US gal = 2.20 UK gal</div>
    <button onclick="calculateBlendingAndEnableUpdates()">Calculate Blend Result</button>
    <div class="result" id="blending_output"></div>
</div>


<script>
        // Theme management
        function toggleTheme() {
            const body = document.body;
            const button = document.querySelector('.theme-toggle');

            if (body.hasAttribute('data-theme')) {
                body.removeAttribute('data-theme');
                button.textContent = '🌙 Dark Mode';
                localStorage.setItem('theme', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                button.textContent = '☀️ Light Mode';
                localStorage.setItem('theme', 'dark');
            }
        }

        // Load saved theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const button = document.querySelector('.theme-toggle');

            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                button.textContent = '☀️ Light Mode';
            }
        }

        // Unit conversion factors to mL
        const volumeConversions = {
            ml: 1,
            us_fl_oz: 29.5735,
            uk_fl_oz: 28.4131,
            us_cup: 236.588,
            us_pint: 473.176,
            uk_pint: 568.261,
            us_quart: 946.353,
            uk_quart: 1136.52,
            us_gallon: 3785.41,
            uk_gallon: 4546.09,
            liter: 1000
        };

        // Sugar conversion factors to grams
        const sugarConversions = {
            grams: 1,
            kg: 1000,
            lbs: 453.592,
            oz: 28.3495,
            us_cups: 200, // Approximate for granulated sugar
            uk_cups: 227  // UK cup is slightly larger
        };

        function convertToMl(value, unit) {
            return value * volumeConversions[unit];
        }

        function convertFromMl(valueInMl, targetUnit) {
            return valueInMl / volumeConversions[targetUnit];
        }

        function convertToGrams(value, unit) {
            return value * sugarConversions[unit];
        }

        function convertFromGrams(valueInGrams, targetUnit) {
            return valueInGrams / sugarConversions[targetUnit];
        }

        // Common volume unit options for all dropdowns
        const commonVolumeOptions = `
            <option value="ml">mL</option>
            <option value="us_fl_oz">US fl oz</option>
            <option value="uk_fl_oz">UK fl oz</option>
            <option value="us_cup">US cup</option>
            <option value="us_pint">US pint</option>
            <option value="uk_pint">UK pint</option>
            <option value="us_quart">US quart</option>
            <option value="uk_quart">UK quart</option>
            <option value="us_gallon">US gallon</option>
            <option value="uk_gallon">UK gallon</option>
            <option value="liter">Liter</option>
        `;

        function updateSugarDisplay() {
            const value = parseFloat(document.getElementById("sugar_amount").value) || 0;
            const unit = document.getElementById("sugar_unit").value;
            const valueInGrams = convertToGrams(value, unit);

            const kg = convertFromGrams(valueInGrams, 'kg');
            const lbs = convertFromGrams(valueInGrams, 'lbs');
            const oz = convertFromGrams(valueInGrams, 'oz');

            document.getElementById("sugar_note").textContent =
                `${valueInGrams.toFixed(0)} g = ${kg.toFixed(2)} kg = ${lbs.toFixed(2)} lbs = ${oz.toFixed(1)} oz`;
        }

        function updateVolumeDisplay() {
            const value = parseFloat(document.getElementById("volume_input").value) || 0;
            const unit = document.getElementById("volume_unit").value;
            const valueInMl = convertToMl(value, unit);

            const usFlOz = convertFromMl(valueInMl, 'us_fl_oz');
            const ukFlOz = convertFromMl(valueInMl, 'uk_fl_oz');

            document.getElementById("volume_note").textContent =
                `${valueInMl.toFixed(0)} mL = ${usFlOz.toFixed(2)} US fl oz = ${ukFlOz.toFixed(2)} UK fl oz`;
        }

        function updateVolumeDisplaySG() {
            const value = parseFloat(document.getElementById("volume_input_sg").value) || 0;
            const unit = document.getElementById("volume_unit_sg").value;
            const valueInMl = convertToMl(value, unit);

            const usFlOz = convertFromMl(valueInMl, 'us_fl_oz');
            const ukFlOz = convertFromMl(valueInMl, 'uk_fl_oz');

            document.getElementById("volume_note_sg").textContent =
                `${valueInMl.toFixed(0)} mL = ${usFlOz.toFixed(2)} US fl oz = ${ukFlOz.toFixed(2)} UK fl oz`;
        }

        function updateBatchVolumeDisplay() {
            const value = parseFloat(document.getElementById("volume_liters").value) || 0;
            const unit = document.getElementById("batch_volume_unit").value;
            const valueInL = unit === 'liter' ? value : convertToMl(value, unit) / 1000;

            const usGal = convertFromMl(valueInL * 1000, 'us_gallon');
            const ukGal = convertFromMl(valueInL * 1000, 'uk_gallon');

            document.getElementById("batch_volume_note").textContent =
                `${valueInL.toFixed(1)} L = ${usGal.toFixed(2)} US gal = ${ukGal.toFixed(2)} UK gal`;
        }

        function updateTargetVolumeDisplay() {
            const value = parseFloat(document.getElementById("target_volume").value) || 0;
            const unit = document.getElementById("target_volume_unit").value;
            const valueInL = unit === 'liter' ? value : convertToMl(value, unit) / 1000;

            const usGal = convertFromMl(valueInL * 1000, 'us_gallon');
            const ukGal = convertFromMl(valueInL * 1000, 'uk_gallon');

            document.getElementById("target_volume_note").textContent =
                `${valueInL.toFixed(1)} L = ${usGal.toFixed(2)} US gal = ${ukGal.toFixed(2)} UK gal`;
        }

        function updatePrimeVolumeDisplay() {
            const value = parseFloat(document.getElementById("prime_volume").value) || 0;
            const unit = document.getElementById("prime_volume_unit").value;
            const valueInL = unit === 'liter' ? value : convertToMl(value, unit) / 1000;

            const usGal = convertFromMl(valueInL * 1000, 'us_gallon');
            const ukGal = convertFromMl(valueInL * 1000, 'uk_gallon');

            document.getElementById("prime_volume_note").textContent =
                `${valueInL.toFixed(1)} L = ${usGal.toFixed(2)} US gal = ${ukGal.toFixed(2)} UK gal`;
        }

        function updateDilutionCurrentVolumeDisplay() {
            const value = parseFloat(document.getElementById("current_volume").value) || 0;
            const unit = document.getElementById("current_volume_unit").value;
            const valueInL = unit === 'liter' ? value : convertToMl(value, unit) / 1000;

            const usGal = convertFromMl(valueInL * 1000, 'us_gallon');
            const ukGal = convertFromMl(valueInL * 1000, 'uk_gallon');

            document.getElementById("current_volume_note").textContent =
                `${valueInL.toFixed(1)} L = ${usGal.toFixed(2)} US gal = ${ukGal.toFixed(2)} UK gal`;
        }

        function updateBatch1VolumeDisplay() {
            const value = parseFloat(document.getElementById("batch1_volume").value) || 0;
            const unit = document.getElementById("batch1_volume_unit").value;
            const valueInL = unit === 'liter' ? value : convertToMl(value, unit) / 1000;

            const usGal = convertFromMl(valueInL * 1000, 'us_gallon');
            const ukGal = convertFromMl(valueInL * 1000, 'uk_gallon');

            document.getElementById("batch1_volume_note").textContent =
                `${valueInL.toFixed(1)} L = ${usGal.toFixed(2)} US gal = ${ukGal.toFixed(2)} UK gal`;
        }

        function updateBatch2VolumeDisplay() {
            const value = parseFloat(document.getElementById("batch2_volume").value) || 0;
            const unit = document.getElementById("batch2_volume_unit").value;
            const valueInL = unit === 'liter' ? value : convertToMl(value, unit) / 1000;

            const usGal = convertFromMl(valueInL * 1000, 'us_gallon');
            const ukGal = convertFromMl(valueInL * 1000, 'uk_gallon');

            document.getElementById("batch2_volume_note").textContent =
                `${valueInL.toFixed(1)} L = ${usGal.toFixed(2)} US gal = ${ukGal.toFixed(2)} UK gal`;
        }

        function updateDilutionCalorieVolumeDisplay() {
            const value = parseFloat(document.getElementById("dilution_calorie_volume_input").value) || 0;
            const unit = document.getElementById("dilution_calorie_volume_unit").value;
            const valueInMl = convertToMl(value, unit);

            const usFlOz = convertFromMl(valueInMl, 'us_fl_oz');
            const ukFlOz = convertFromMl(valueInMl, 'uk_fl_oz');

            document.getElementById("dilution_calorie_note").textContent =
                `${valueInMl.toFixed(0)} mL = ${usFlOz.toFixed(2)} US fl oz = ${ukFlOz.toFixed(2)} UK fl oz`;
        }


        let abvChartRefractometer;
        let abvChartHydrometer;

        function updateChart(canvasId, sgVals, abvVal, labels = ['Original', 'Final']) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            let chart;

            if (canvasId === 'abvChartRefractometer') {
                // Chart for refractometer is removed, so this block is no longer needed
                // if (abvChartRefractometer) abvChartRefractometer.destroy();
                // chart = new Chart(ctx, {
                //     type: 'line',
                //     data: {
                //         labels: labels, // Use provided labels
                //         datasets: [{
                //             label: 'SG Progress',
                //             data: sgVals,
                //             borderColor: 'teal',
                //             fill: false,
                //             tension: 0.1
                //         }]
                //     },
                //     options: {
                //         plugins: {
                //             title: { display: true, text: `Estimated ABV: ${abvVal}%` }
                //         },
                //         scales: {
                //             y: { beginAtZero: false }
                //         }
                //     }
                // });
                // abvChartRefractometer = chart;
            } else if (canvasId === 'abvChartHydrometer') {
                if (abvChartHydrometer) abvChartHydrometer.destroy();
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels, // Use provided labels
                        datasets: [{
                            label: 'SG Progress',
                            data: sgVals,
                            borderColor: 'teal',
                            fill: false,
                            tension: 0.1
                        }]
                    },
                    options: {
                        plugins: {
                            title: { display: true, text: `Estimated ABV: ${abvVal}%` }
                        },
                        scales: {
                            y: { beginAtZero: false }
                        }
                    }
                });
                abvChartHydrometer = chart;
            }
        }

        // Function to convert Brix to Refractive Index (RI) - KEPT FOR REFERENCE, NOT USED IN FG CALC
        function brixToRI(brix) {
            return 1.33302 + 0.001427193 * brix + 0.000005791157 * Math.pow(brix, 2);
        }

        function calculate() {
            const ogBrix = parseFloat(document.getElementById("og_brix").value);
            const fgBrix = parseFloat(document.getElementById("fg_brix").value);
            const wcf = parseFloat(document.getElementById("wcf").value);
            const volumeInput = parseFloat(document.getElementById("volume_input").value);
            const volumeUnit = document.getElementById("volume_unit").value;
            const volumeMl = convertToMl(volumeInput, volumeUnit);

            if (isNaN(ogBrix) || isNaN(fgBrix) || isNaN(wcf) || isNaN(volumeMl)) {
                 document.getElementById("output").innerHTML =
                    '<span class="active">Please enter valid numeric values for Brix, WCF, and Volume.</span>';
                // No chart to destroy for refractometer, so removed the chart.destroy() call here.
                return;
            }


            // OG calculation from corrected OBrix
            const correctedObrix = ogBrix / wcf;
            const og_sg = 1 + (correctedObrix / (258.6 - ((correctedObrix / 258.2) * 227.1)));

            // Reverted FG calculation using Brix values directly (from brix_logic_patch.html)
            // This formula is known to provide more accurate "dry" results for refractometer readings.
            const FG = 1.0000
                        - 0.00085683 * ogBrix
                        + 0.0034941 * fgBrix
                        + 0.0000051118 * Math.pow(ogBrix, 2)
                        - 0.000013228 * Math.pow(fgBrix, 2)
                        - 0.00000083764 * Math.pow(ogBrix, 3)
                        + 0.00000018017 * Math.pow(fgBrix, 3);

            const abv_std = (og_sg - FG) * 131.25;
            const abv_alt = ((76.08 * (og_sg - FG)) / (1.775 - og_sg)) * (FG / 0.794);

            // Calculate residual sugar in g/L and for the specified volume
            const residualSugarGL = calculateResidualSugar(FG);
            const residualSugarInVolume = (residualSugarGL * volumeMl) / 1000; // Convert to grams in the specified volume

            // Calculate calories for Alcohol & Sugar
            const alcoholAndSugarCalories = (volumeMl * (abv_std / 100) * 0.789) * 7 + (residualSugarInVolume * 4);

            // Calculate sweetness percentage for visual display (0-100%)
            const sweetnessPercentage = calculateSweetnessPercentage(residualSugarGL);

            // Calculate sweetness classification
            const sweetness = getSweetnessClassification(FG, Math.max(abv_std, abv_alt));

            const final_target_FG = 1.0001;
            let fermentation_progress = 0;
            if ((og_sg - final_target_FG) !== 0) {
                fermentation_progress = ((og_sg - FG) / (og_sg - final_target_FG)) * 100;
            } else if (og_sg <= FG) {
                fermentation_progress = (FG >= final_target_FG && og_sg >= final_target_FG) ? 100 : 0;
            }


            let statusText = "";
            let statusClass = "status ";
            let progressClass = "progress ";

            if (fermentation_progress >= 99 && FG <= (final_target_FG + 0.001)) {
                statusText = "Fermentation Complete (dry).";
                statusClass += "complete";
                progressClass += "complete";
            } else if (fermentation_progress >= 93) {
                 statusText = "Fermentation nearly complete or complete (check FG).";
                statusClass += "complete";
                progressClass += "complete";
            } else {
                statusText = "Fermentation still active or in early stages.";
                statusClass += "active";
                progressClass += "active";
            }

            // Calculate Attenuation
            let attenuation = 0;
            if ((og_sg - 1) !== 0) {
                attenuation = ((og_sg - FG) / (og_sg - 1)) * 100;
            }


            // Get unit display text
            const unitDisplayText = getUnitDisplayText(volumeUnit);
            const volumeDisplayValue = volumeUnit === 'ml' ? volumeMl.toFixed(0) : volumeInput.toFixed(volumeInput % 1 === 0 ? 0 : 2);

            document.getElementById("output").innerHTML = `
                <strong>Corrected OG (SG):</strong> ${og_sg.toFixed(4)}<br>
                <strong>Corrected FG (SG):</strong> ${FG.toFixed(4)}<br>
                <strong>ABV:</strong> ${abv_std.toFixed(2)}%<br>
                <strong>Apparent Attenuation:</strong> ${attenuation.toFixed(2)}%<br>
                <strong>Residual Sugar:</strong> ${residualSugarGL.toFixed(1)} g/L (${residualSugarInVolume.toFixed(1)}g in ${volumeDisplayValue}${unitDisplayText})<br>
                <strong>Sweetness Level:</strong> ${sweetnessPercentage.toFixed(0)}%<br>
                <div class="sweetness-bar-container">
                    <div class="sweetness-indicator" style="left: ${Math.min(100, Math.max(0, sweetnessPercentage))}%;"></div>
                </div>
                <div class="sweetness-labels">
                    <span>Bone Dry (0%)</span>
                    <span>Semi-Sweet (50%)</span>
                    <span>Dessert Sweet (100%)</span>
                </div>
                <strong>Estimated Calories per ${volumeDisplayValue}${unitDisplayText} for Alcohol & Sugar:</strong> ${alcoholAndSugarCalories.toFixed(0)} Kcal<br>
                <strong>Sweetness Classification:</strong> <span class="sweetness">${sweetness.simple}</span> (${sweetness.detailed})<br>
                <div class="${progressClass}">Fermentation Progress: ${fermentation_progress.toFixed(1)}%</div>
                <div class="${statusClass}">${statusText}</div>
            `;

            // Removed chart update for refractometer
            // updateChart('abvChartRefractometer', [og_sg, FG], abv_std.toFixed(2));
        }

        let sgReadingCounter = 0; // To give unique IDs to new fields

        function addSgReadingField() {
            sgReadingCounter++;
            const container = document.getElementById('sg_readings_container');

            const readingDiv = document.createElement('div');
            readingDiv.className = 'volume-input-group'; // Reuse styling
            readingDiv.dataset.readingId = sgReadingCounter; // Unique identifier for the row

            const labelDay = document.createElement('label');
            labelDay.htmlFor = `sg_day_${sgReadingCounter}`;
            labelDay.textContent = `Day/Time ${sgReadingCounter}:`;

            const inputDay = document.createElement('input');
            inputDay.type = 'text';
            inputDay.id = `sg_day_${sgReadingCounter}`;
            inputDay.value = `Day ${sgReadingCounter}`; // Default value
            inputDay.oninput = calculateSG; // Update chart labels on input

            const labelGravity = document.createElement('label');
            labelGravity.htmlFor = `sg_value_${sgReadingCounter}`;
            labelGravity.textContent = `Current Gravity:`;

            const inputGravity = document.createElement('input');
            inputGravity.type = 'number';
            inputGravity.step = '0.001';
            inputGravity.id = `sg_value_${sgReadingCounter}`;
            inputGravity.value = '1.005'; // Default value
            inputGravity.oninput = calculateSG; // Update chart data on input

            readingDiv.appendChild(labelDay);
            readingDiv.appendChild(inputDay);
            readingDiv.appendChild(labelGravity);
            readingDiv.appendChild(inputGravity);

            container.appendChild(readingDiv);

            // Call calculateSG immediately after adding a new field to update the graph
            calculateSG();
        }

        // Helper function to get all current SG calculator stats
        function getSgCalculatorStats() {
            const og_sg = parseFloat(document.getElementById("og_sg").value);
            const initial_fg_sg = parseFloat(document.getElementById("fg_sg").value); // Store initial FG

            const chartLabels = ['Original Gravity'];
            const chartData = [og_sg];
            const allReadings = [{ label: 'Original Gravity', value: og_sg }];

            const dynamicReadingDivs = document.querySelectorAll('#sg_readings_container > div');
            dynamicReadingDivs.forEach(div => {
                const dayInput = div.querySelector('input[type="text"]');
                const gravityInput = div.querySelector('input[type="number"]');
                const dayLabel = dayInput ? dayInput.value : 'Unknown Day';
                const currentGravity = parseFloat(gravityInput.value);
                if (!isNaN(currentGravity)) {
                    chartLabels.push(dayLabel);
                    chartData.push(currentGravity);
                    allReadings.push({ label: dayLabel, value: currentGravity });
                }
            });

            // Determine the final gravity to use for calculations and display
            // This will be the last reading in the chartData array, which includes dynamic readings
            let fg_sg_final = chartData[chartData.length - 1];

            // If no dynamic readings were added, ensure the initial FG input is considered the final reading
            // This condition checks if only OG is present in chartData (meaning no dynamic readings were added yet)
            if (chartData.length === 1 && dynamicReadingDivs.length === 0) {
                chartLabels.push('Final Gravity'); // Add 'Final Gravity' label for the initial FG input
                chartData.push(initial_fg_sg);
                allReadings.push({ label: 'Final Gravity', value: initial_fg_sg });
                fg_sg_final = initial_fg_sg; // Use the initial FG input as the final gravity
            }


            const abv_std = (og_sg - fg_sg_final) * 131.25;
            const abv_alt = ((76.08 * (og_sg - fg_sg_final)) / (1.775 - og_sg)) * (fg_sg_final / 0.794);
            const residualSugarGL = calculateResidualSugar(fg_sg_final);
            const attenuation = (og_sg - 1) !== 0 ? ((og_sg - fg_sg_final) / (og_sg - 1)) * 100 : 0;
            const final_target_FG = 1.0001;
            let fermentation_progress = 0;
            if ((og_sg - final_target_FG) !== 0) {
                fermentation_progress = ((og_sg - fg_sg_final) / (og_sg - final_target_FG)) * 100;
            } else if (og_sg <= fg_sg_final) {
                fermentation_progress = (fg_sg_final >= final_target_FG && og_sg >= final_target_FG) ? 100 : 0;
            }

            return {
                og_sg: og_sg,
                fg_sg: fg_sg_final, // This now correctly reflects the last reading
                abv_std: abv_std,
                abv_alt: abv_alt,
                attenuation: attenuation,
                residualSugarGL: residualSugarGL,
                fermentation_progress: fermentation_progress,
                chartLabels: chartLabels,
                chartData: chartData,
                allReadings: allReadings // Include all readings for output
            };
        }


        function calculateSG() {
            const stats = getSgCalculatorStats(); // Get all stats and data
            const volumeInput = parseFloat(document.getElementById("volume_input_sg").value);
            const volumeUnit = document.getElementById("volume_unit_sg").value;
            const volumeMl = convertToMl(volumeInput, volumeUnit);


            if (isNaN(stats.og_sg) || isNaN(stats.fg_sg) || isNaN(volumeMl)) {
                document.getElementById("sg_output").innerHTML = '<span class="active">Please enter valid numeric values for OG, FG, and Volume.</span>';
                if (abvChartHydrometer) { abvChartHydrometer.destroy(); abvChartHydrometer = null; }
                return;
            }

            const residualSugarInVolume = (stats.residualSugarGL * volumeMl) / 1000;
            const alcoholAndSugarCalories = (volumeMl * (stats.abv_std / 100) * 0.789) * 7 + (residualSugarInVolume * 4);
            const sweetnessPercentage = calculateSweetnessPercentage(stats.residualSugarGL);
            const sweetness = getSweetnessClassification(stats.fg_sg, Math.max(stats.abv_std, stats.abv_alt));


            let statusText = "";
            let statusClass = "status ";
            let progressClass = "progress ";

            // Modified condition for "Fermentation Complete (dry)."
            if (stats.fermentation_progress >= 99 && stats.fg_sg <= 1.000) { // Check if FG is 1.000 or below for "dry"
                statusText = "Fermentation Complete (dry).";
                statusClass += "complete";
                progressClass += "complete";
            } else if (stats.fermentation_progress >= 93) {
                statusText = "Fermentation nearly complete or complete (check FG).";
                statusClass += "complete";
                progressClass += "complete";
            } else if (stats.fermentation_progress >= 83) {
                statusText = "Fermentation well underway.";
                statusClass += "nearly";
                progressClass += "nearly";
            } else {
                statusText = "Fermentation still active or in early stages.";
                statusClass += "active";
                progressClass += "active";
            }

            const unitDisplayText = getUnitDisplayText(volumeUnit);
            const volumeDisplayValue = volumeUnit === 'ml' ? volumeMl.toFixed(0) : volumeInput.toFixed(volumeInput % 1 === 0 ? 0 : 2);

            document.getElementById("sg_output").innerHTML = `
                <strong>Original Gravity (OG):</strong> ${stats.og_sg.toFixed(3)}<br>
                <strong>Final Gravity (FG):</strong> ${stats.fg_sg.toFixed(3)} (based on most recent reading)<br>
                <strong>ABV (Standard Formula):</strong> ${stats.abv_std.toFixed(2)}%<br>
                <strong>ABV (Alternate Formula):</strong> ${stats.abv_alt.toFixed(2)}%<br>
                <strong>Apparent Attenuation:</strong> ${stats.attenuation.toFixed(2)}%<br>
                <strong>Residual Sugar:</strong> ${stats.residualSugarGL.toFixed(1)} g/L (${residualSugarInVolume.toFixed(1)}g in ${volumeDisplayValue}${unitDisplayText})<br>
                <strong>Sweetness Level:</strong> ${sweetnessPercentage.toFixed(0)}%<br>
                <div class="sweetness-bar-container">
                    <div class="sweetness-indicator" style="left: ${Math.min(100, Math.max(0, sweetnessPercentage))}%;"></div>
                </div>
                <div class="sweetness-labels">
                    <span>Bone Dry (0%)</span>
                    <span>Semi-Sweet (50%)</span>
                    <span>Dessert Sweet (100%)</span>
                </div>
                <strong>Estimated Calories per ${volumeDisplayValue}${unitDisplayText} for Alcohol & Sugar:</strong> ${alcoholAndSugarCalories.toFixed(0)} Kcal<br>
                <strong>Sweetness Classification:</strong> <span class="sweetness">${sweetness.simple}</span> (${sweetness.detailed})<br>
                <div class="${progressClass}">Fermentation Progress: ${stats.fermentation_progress.toFixed(1)}%</div>
                <div class="${statusClass}">${statusText}</div>
            `;
            updateChart('abvChartHydrometer', stats.chartData, stats.abv_std.toFixed(2), stats.chartLabels);
        }


        function getUnitDisplayText(unit) {
            const unitNames = {
                ml: 'mL',
                us_fl_oz: ' US fl oz',
                uk_fl_oz: ' UK fl oz',
                us_cup: ' US cups',
                us_pint: ' US pints',
                uk_pint: ' UK pints',
                us_quart: ' US quarts',
                uk_quart: ' UK quarts',
                us_gallon: ' US gallons',
                uk_gallon: ' UK gallons',
                liter: 'L'
            };
            return unitNames[unit] || '';
        }

        function calculateSweetnessPercentage(residualSugarGL) {
            // Convert residual sugar g/L to a 0-100% sweetness scale
            // 0 g/L = 0% (bone dry)
            // 50+ g/L = 100% (dessert sweet)
            // Use a logarithmic scale to better represent perceived sweetness
            const maxSugar = 50; // g/L for 100% sweetness
            let percentage = Math.min(100, (residualSugarGL / maxSugar) * 100);

            // Apply slight curve to make lower values more sensitive
            percentage = Math.pow(percentage / 100, 0.8) * 100;

            return Math.max(0, percentage);
        }

        function calculateResidualSugar(fg) {
            // Convert final gravity to residual sugar in g/L
            // Formula: (FG - 1.000) * 1000 * 2.5
            // This converts specific gravity points to grams per liter
            // The 2.5 factor accounts for the density relationship of dissolved sugars
            const residualSugarGL = Math.max(0, (fg - 1.000) * 1000 * 2.5);
            return residualSugarGL;
        }

        function getSweetnessClassification(fg, abv) {
            // Calculate approximate residual sugar percentage using the same formula as residual sugar g/L
            const residualSugarGL = Math.max(0, (fg - 1.000) * 1000 * 2.5);
            const residualSugar = residualSugarGL / 10; // Convert g/L to approximate percentage

            let simple, detailed;

            // Simple classification (2012 Wisconsin State Fair)
            if (fg <= 1.002) {
                simple = "Dry";
            } else if (fg <= 1.010) {
                simple = "Semi-Sweet";
            } else {
                simple = "Sweet";
            }

            // Detailed classification
            if (fg < 1.000 || residualSugar < 0.5) { // fg < 1.000 is essentially "bone dry" or an error
                detailed = "Dry Wine - virtually no residual sugar";
            } else if (residualSugar <= 1.0 && abv < 14) { // up to 10 g/L RS
                detailed = "Off-Dry Wine - not completely dry but suitable for meals";
            } else if (residualSugar <= 4.0 && abv < 14) { // 10-40 g/L RS
                detailed = "Social Wine - semi-dry/semi-sweet, enjoyed with snacks";
            } else if (residualSugar > 4.0) { // >40 g/L RS
                detailed = "Dessert Wine - very sweet, served with desserts";
            } else { // This case might be hard to reach if abv is always a number.
                     // It's a fallback if other conditions for detailed are not met.
                detailed = "Specialty Wine - check characteristics";
            }

            return { simple, detailed };
        }

        function calculateCalories(og, fg, volumeMl) {
            if (!og || !fg || og <= 0 || fg <= 0 || isNaN(og) || isNaN(fg)) {
                return 0;
            }
            if (!volumeMl || volumeMl <= 0 || isNaN(volumeMl)) {
                return 0;
            }

            // Convert SG to Plato
            const ogPlato = (og - 1) * 1000 / 4;
            const fgPlato = (fg - 1) * 1000 / 4;

            // Calculate Real Extract using proper brewing formula
            const realExtract = (0.1808 * ogPlato) + (0.8192 * fgPlato);

            // Calculate ABW (Alcohol by Weight)
            const abw = (ogPlato - realExtract) / (2.0665 - (0.010665 * ogPlato));

            // Calculate calories per 12oz using adjusted formula to match reference
            const caloriesPer12oz = ((6.9 * abw) + 4.0 * (realExtract - 0.1)) * fg * 3.24;

            // Scale to requested volume (12oz = 354.882mL)
            const calories = (caloriesPer12oz * volumeMl) / 354.882;

            return calories > 0 ? calories : 0; // Ensure non-negative calories
        }

        function calculateSugarABV() {
            const sugarInput = parseFloat(document.getElementById("sugar_amount").value);
            const sugarUnit = document.getElementById("sugar_unit").value;
            const sugar = convertToGrams(sugarInput, sugarUnit); // Convert input sugar to grams

            const volumeInput = parseFloat(document.getElementById("volume_liters").value);
            const volumeUnit = document.getElementById("batch_volume_unit").value;
            const factor = parseFloat(document.getElementById("conversion_factor").value);

            // Convert volume to liters
            const volume = volumeUnit === 'liter' ? volumeInput : convertToMl(volumeInput, volumeUnit) / 1000;

            if (!isNaN(sugar) && !isNaN(volume) && !isNaN(factor) && sugar > 0 && volume > 0 && factor > 0) {
                const abv = (sugar / (volume * factor));

                // Calculate estimated OG (SG) from sugar content using corrected formulas
                const sugar_concentration_gl = sugar / volume;
                // Corrected Plato conversion: 1° Plato = 10 g/L of sugar (approximately)
                const estimated_plato = sugar_concentration_gl / 9.4;
                // Corrected Plato to SG conversion
                const estimated_og_sg = 1 + (estimated_plato / (258.6 - (estimated_plato / 258.2 * 227.1)));

                const unitText = volumeUnit === 'liter' ? 'L' : getUnitDisplayText(volumeUnit).trim();
                const displayVolume = volumeInput.toFixed(volumeInput % 1 === 0 ? 0 : 2);

                document.getElementById("sugar_abv_output").innerHTML =
                    // `<strong>Estimated OG (SG):</strong> ${estimated_og_sg.toFixed(3)}<br>` +
                    `<strong>Estimated ABV:</strong> ${abv.toFixed(2)}% (based on ${factor}g sugar per 1% ABV per liter)<br>` +
                    `<strong>Batch size:</strong> ${displayVolume} ${unitText} (${volume.toFixed(1)}L)`;
            } else {
                document.getElementById("sugar_abv_output").innerHTML =
                    `<span class="active">Please enter valid non-zero sugar, volume, and conversion factor values.</span>`;
            }
        }

        function calculateRequiredSugar() {
            const abv = parseFloat(document.getElementById("target_abv").value);
            const volumeInput = parseFloat(document.getElementById("target_volume").value);
            const volumeUnit = document.getElementById("target_volume_unit").value;
            const factor = parseFloat(document.getElementById("target_factor").value);

            // Convert volume to liters
            const volume = volumeUnit === 'liter' ? volumeInput : convertToMl(volumeInput, volumeUnit) / 1000;

            if (!isNaN(abv) && !isNaN(volume) && !isNaN(factor) && abv > 0 && volume > 0 && factor > 0) {
                const sugar_required = abv * volume * factor;
                const sugar_required_oz = convertFromGrams(sugar_required, 'oz');

                // Calculate estimated OG (SG) from required sugar using corrected formulas
                const sugar_concentration_gl = sugar_required / volume;
                // Corrected Plato conversion: 1° Plato = 10 g/L of sugar (approximately)
                   const estimated_plato = sugar_concentration_gl / 9.4;
                // Corrected Plato to SG conversion
                const estimated_og_sg = 1 + (estimated_plato / (258.6 - (estimated_plato / 258.2 * 227.1)));

                const unitText = volumeUnit === 'liter' ? 'L' : getUnitDisplayText(volumeUnit).trim();
                const displayVolume = volumeInput.toFixed(volumeInput % 1 === 0 ? 0 : 2);

                document.getElementById("required_sugar_output").innerHTML =
                  //`<strong>Estimated OG (SG):</strong> ${estimated_og_sg.toFixed(3)}<br>` +
                    `<strong>Required Sugar:</strong> ${sugar_required.toFixed(2)} grams (${sugar_required_oz.toFixed(2)} oz)<br>
                    (to reach ${abv.toFixed(2)}% ABV in ${displayVolume} ${unitText} [${volume.toFixed(1)}L] using ${factor}g/L per 1% ABV)`;
            } else {
                document.getElementById("required_sugar_output").innerHTML =
                    `<span class="active">Please enter valid non-zero ABV, volume, and conversion factor values.</span>`;
            }
        }

        function calculatePrimingSugar() {
            const volumeInput = parseFloat(document.getElementById("prime_volume").value);
            const volumeUnit = document.getElementById("prime_volume_unit").value;
            const co2Volumes = parseFloat(document.getElementById("co2_volumes").value);
            const currentTemp = parseFloat(document.getElementById("current_temp").value);
            const sugarType = document.getElementById("sugar_type").value;

            // Convert volume to liters
            const volumeLiters = volumeUnit === 'liter' ? volumeInput : convertToMl(volumeInput, volumeUnit) / 1000;

            // CO2 saturation at given temperature (volumes of CO2 per volume of liquid)
            // Approx values, simplified for calculator
            let co2Saturation;
            if (currentTemp <= 0) co2Saturation = 1.7;
            else if (currentTemp <= 4) co2Saturation = 1.5;
            else if (currentTemp <= 8) co2Saturation = 1.3;
            else if (currentTemp <= 12) co2Saturation = 1.1;
            else if (currentTemp <= 16) co2Saturation = 0.9;
            else if (currentTemp <= 20) co2Saturation = 0.8;
            else co2Saturation = 0.7; // Higher temps

            // Sugar factors (grams per liter to achieve 1 volume of CO2)
            let sugarFactor;
            switch (sugarType) {
                case 'table':
                    sugarFactor = 4.0; // grams of sucrose per liter per volume CO2
                    break;
                case 'corn':
                    sugarFactor = 4.3; // grams of dextrose per liter per volume CO2
                    break;
                case 'dme':
                    sugarFactor = 6.0; // grams of DME per liter per volume CO2
                    break;
                case 'honey':
                    sugarFactor = 5.0; // grams of honey per liter per volume CO2 (approx, depends on water content)
                    break;
                default:
                    sugarFactor = 4.0;
            }

            if (!isNaN(volumeLiters) && !isNaN(co2Volumes) && !isNaN(currentTemp) && volumeLiters > 0 && co2Volumes > 0) {
                // Calculate required CO2 from priming
                const requiredCo2FromPriming = co2Volumes - co2Saturation;

                if (requiredCo2FromPriming <= 0) {
                    document.getElementById("priming_output").innerHTML =
                        `<span class="active">No priming sugar needed, brew is likely already carbonated enough at this temperature, or desired CO2 is too low.</span>`;
                    return;
                }

                const primingSugarGrams = requiredCo2FromPriming * volumeLiters * sugarFactor;
                const primingSugarOunces = convertFromGrams(primingSugarGrams, 'oz');

                const unitText = volumeUnit === 'liter' ? 'L' : getUnitDisplayText(volumeUnit).trim();
                const displayVolume = volumeInput.toFixed(volumeInput % 1 === 0 ? 0 : 2);

                document.getElementById("priming_output").innerHTML =
                    `<strong>Required Priming Sugar:</strong> ${primingSugarGrams.toFixed(2)} grams (${primingSugarOunces.toFixed(2)} oz) (${sugarType})<br>
                    (for ${co2Volumes.toFixed(1)} volumes CO2 in ${displayVolume} ${unitText} at ${currentTemp}°C)`;
            } else {
                document.getElementById("priming_output").innerHTML =
                    `<span class="active">Please enter valid non-zero values for volume, desired CO2, and current temperature.</span>`;
            }
        }

        function calculateDilution() {
            const currentAbv = parseFloat(document.getElementById("current_abv").value);
            const currentVolumeInput = parseFloat(document.getElementById("current_volume").value);
            const currentVolumeUnit = document.getElementById("current_volume_unit").value;
            const targetAbv = parseFloat(document.getElementById("target_abv_dilution").value);

            const dilutionCalorieVolumeInput = parseFloat(document.getElementById("dilution_calorie_volume_input").value);
            const dilutionCalorieVolumeUnit = document.getElementById("dilution_calorie_volume_unit").value;

            // Convert current volume to liters
            const currentVolumeL = currentVolumeUnit === 'liter' ? currentVolumeInput : convertToMl(currentVolumeInput, currentVolumeUnit) / 1000;
            const dilutionCalorieVolumeMl = convertToMl(dilutionCalorieVolumeInput, dilutionCalorieVolumeUnit);


            if (isNaN(currentAbv) || isNaN(currentVolumeL) || isNaN(targetAbv) ||
                currentAbv < 0 || currentVolumeL <= 0 || targetAbv < 0) {
                document.getElementById("dilution_output").innerHTML =
                    `<span class="active">Please enter valid non-negative ABV and non-zero volume.</span>`;
                return;
            }

            if (targetAbv >= currentAbv && currentAbv !== 0) { // Allow targetAbv to be 0 for non-alcoholic
                document.getElementById("dilution_output").innerHTML =
                    `<span class="active">Target ABV must be lower than Current ABV for dilution (unless current ABV is 0).</span>`;
                return;
            }

            let waterNeededL = 0;
            if (targetAbv !== 0) {
                waterNeededL = (currentAbv * currentVolumeL / targetAbv) - currentVolumeL;
            } else if (currentAbv > 0) { // Diluting to 0 ABV
                waterNeededL = (currentAbv * currentVolumeL) / 0.0001; // Effectively infinite water
            }
            // If currentAbv is 0 and targetAbv is 0, waterNeededL remains 0.

            const totalVolumeL = currentVolumeL + waterNeededL;
            const totalVolumeMl = totalVolumeL * 1000;

            // Calculate total Kcal for the final diluted product (assuming 0 residual sugar for dilution)
            const totalKcal = (totalVolumeMl * (targetAbv / 100) * 0.789) * 7;

            // Calculate Kcal for the user-specified volume
            const specificKcal = (dilutionCalorieVolumeMl * (targetAbv / 100) * 0.789) * 7;

            const unitText = currentVolumeUnit === 'liter' ? 'L' : getUnitDisplayText(currentVolumeUnit).trim();
            const displayCurrentVolume = currentVolumeInput.toFixed(currentVolumeInput % 1 === 0 ? 0 : 2);

            const dilutionCalorieUnitDisplayText = getUnitDisplayText(dilutionCalorieVolumeUnit);
            const dilutionCalorieVolumeDisplayValue = dilutionCalorieVolumeUnit === 'ml' ? dilutionCalorieVolumeMl.toFixed(0) : dilutionCalorieVolumeInput.toFixed(dilutionCalorieVolumeInput % 1 === 0 ? 0 : 2);

            // Convert liters to US fl oz for display
            const waterNeededUsFlOz = convertFromMl(waterNeededL * 1000, 'us_fl_oz');
            const totalVolumeUsFlOz = convertFromMl(totalVolumeL * 1000, 'us_fl_oz');


            document.getElementById("dilution_output").innerHTML =
                `<strong>Water Needed:</strong> ${waterNeededL.toFixed(2)} Liters (${waterNeededUsFlOz.toFixed(2)} US fl oz)<br>
                <strong>Total Final Volume:</strong> ${totalVolumeL.toFixed(2)} Liters (${totalVolumeUsFlOz.toFixed(2)} US fl oz)<br>
                <strong>Estimated Total Kcal:</strong> ${totalKcal.toFixed(0)} Kcal<br>
                <strong>Estimated Kcal per ${dilutionCalorieVolumeDisplayValue}${dilutionCalorieUnitDisplayText}:</strong> ${specificKcal.toFixed(0)} Kcal<br>
                (to dilute ${displayCurrentVolume} ${unitText} at ${currentAbv.toFixed(1)}% ABV to ${targetAbv.toFixed(1)}% ABV)`;
        }

        function calculateBlending() {
            const abv1 = parseFloat(document.getElementById("batch1_abv").value);
            const volume1Input = parseFloat(document.getElementById("batch1_volume").value);
            const volume1Unit = document.getElementById("batch1_volume_unit").value;
            const abv2 = parseFloat(document.getElementById("batch2_abv").value);
            const volume2Input = parseFloat(document.getElementById("batch2_volume").value);
            const volume2Unit = document.getElementById("batch2_volume_unit").value;

            // Convert volumes to liters
            const volume1L = volume1Unit === 'liter' ? volume1Input : convertToMl(volume1Input, volume1Unit) / 1000;
            const volume2L = volume2Unit === 'liter' ? volume2Input : convertToMl(volume2Input, volume2Unit) / 1000;

            if (!isNaN(abv1) && !isNaN(volume1L) && !isNaN(abv2) && !isNaN(volume2L) &&
                volume1L > 0 && volume2L > 0 && abv1 >=0 && abv2 >=0) { // allow 0 ABV for non-alcoholic component

                const totalVolume = volume1L + volume2L;
                if (totalVolume <= 0) { // Should not happen if volume1L & volume2L > 0, but good practice
                     document.getElementById("blending_output").innerHTML =
                        `<span class="active">Total volume is zero or negative. Please check inputs.</span>`;
                    return;
                }
                const blendedAbv = ((abv1 * volume1L) + (abv2 * volume2L)) / totalVolume;

                const unitText1 = volume1Unit === 'liter' ? 'L' : getUnitDisplayText(volume1Unit).trim();
                const displayVolume1 = volume1Input.toFixed(volume1Input % 1 === 0 ? 0 : 2);
                const unitText2 = volume2Unit === 'liter' ? 'L' : getUnitDisplayText(volume2Unit).trim();
                const displayVolume2 = volume2Input.toFixed(volume2Input % 1 === 0 ? 0 : 2);

                document.getElementById("blending_output").innerHTML =
                    `<strong>Blended ABV:</strong> ${blendedAbv.toFixed(2)}%<br>
                    <strong>Total Volume:</strong> ${totalVolume.toFixed(2)} Liters<br>
                    (${displayVolume1} ${unitText1} at ${abv1.toFixed(1)}% ABV + ${displayVolume2} ${unitText2} at ${abv2.toFixed(1)}% ABV)`;
            } else {
                document.getElementById("blending_output").innerHTML =
                    `<span class="active">Please enter valid non-zero volumes and non-negative ABVs for both batches.</span>`;
            }
        }

        // --- New functions to manage initial click and then enable on-the-fly updates ---
        let refractometerCalculatedOnce = false;
        function calculateRefractometerAndEnableUpdates() {
            calculate(); // Perform the initial calculation
            if (!refractometerCalculatedOnce) {
                document.getElementById("og_brix").oninput = calculate;
                document.getElementById("fg_brix").oninput = calculate;
                document.getElementById("wcf").oninput = calculate;
                document.getElementById("volume_input").oninput = () => { updateVolumeDisplay(); calculate(); };
                document.getElementById("volume_unit").onchange = () => { updateVolumeDisplay(); calculate(); };
                refractometerCalculatedOnce = true;
            }
        }

        let hydrometerCalculatedOnce = false;
        function calculateHydrometerAndEnableUpdates() {
            calculateSG();
            if (!hydrometerCalculatedOnce) {
                document.getElementById("og_sg").oninput = calculateSG;
                document.getElementById("fg_sg").oninput = calculateSG;
                document.getElementById("volume_input_sg").oninput = () => { updateVolumeDisplaySG(); calculateSG(); };
                document.getElementById("volume_unit_sg").onchange = () => { updateVolumeDisplaySG(); calculateSG(); };
                hydrometerCalculatedOnce = true;
            }
        }

        let sugarAbvCalculatedOnce = false;
        function calculateSugarABVAndEnableUpdates() {
            calculateSugarABV();
            if (!sugarAbvCalculatedOnce) {
                document.getElementById("sugar_amount").oninput = () => { updateSugarDisplay(); calculateSugarABV(); };
                document.getElementById("sugar_unit").onchange = () => { updateSugarDisplay(); calculateSugarABV(); };
                document.getElementById("volume_liters").oninput = () => { updateBatchVolumeDisplay(); calculateSugarABV(); };
                document.getElementById("batch_volume_unit").onchange = () => { updateBatchVolumeDisplay(); calculateSugarABV(); };
                document.getElementById("conversion_factor").oninput = calculateSugarABV;
                sugarAbvCalculatedOnce = true;
            }
        }

        let targetSugarCalculatedOnce = false;
        function calculateRequiredSugarAndEnableUpdates() {
            calculateRequiredSugar();
            if (!targetSugarCalculatedOnce) {
                document.getElementById("target_abv").oninput = calculateRequiredSugar;
                document.getElementById("target_volume").oninput = () => { updateTargetVolumeDisplay(); calculateRequiredSugar(); };
                document.getElementById("target_volume_unit").onchange = () => { updateTargetVolumeDisplay(); calculateRequiredSugar(); };
                document.getElementById("target_factor").oninput = calculateRequiredSugar;
                targetSugarCalculatedOnce = true;
            }
        }

        let primingSugarCalculatedOnce = false;
        function calculatePrimingSugarAndEnableUpdates() {
            calculatePrimingSugar();
            if (!primingSugarCalculatedOnce) {
                document.getElementById("prime_volume").oninput = () => { updatePrimeVolumeDisplay(); calculatePrimingSugar(); };
                document.getElementById("prime_volume_unit").onchange = () => { updatePrimeVolumeDisplay(); calculatePrimingSugar(); };
                document.getElementById("co2_volumes").oninput = calculatePrimingSugar;
                document.getElementById("current_temp").oninput = calculatePrimingSugar;
                document.getElementById("sugar_type").onchange = calculatePrimingSugar;
                primingSugarCalculatedOnce = true;
            }
        }

        let dilutionCalculatedOnce = false;
        function calculateDilutionAndEnableUpdates() {
            calculateDilution();
            if (!dilutionCalculatedOnce) {
                document.getElementById("current_abv").oninput = calculateDilution;
                document.getElementById("current_volume").oninput = () => { updateDilutionCurrentVolumeDisplay(); calculateDilution(); };
                document.getElementById("current_volume_unit").onchange = () => { updateDilutionCurrentVolumeDisplay(); calculateDilution(); };
                document.getElementById("target_abv_dilution").oninput = calculateDilution;
                document.getElementById("dilution_calorie_volume_input").oninput = () => { updateDilutionCalorieVolumeDisplay(); calculateDilution(); };
                document.getElementById("dilution_calorie_volume_unit").onchange = () => { updateDilutionCalorieVolumeDisplay(); calculateDilution(); };
                dilutionCalculatedOnce = true;
            }
        }

        let blendingCalculatedOnce = false;
        function calculateBlendingAndEnableUpdates() {
            calculateBlending();
            if (!blendingCalculatedOnce) {
                document.getElementById("batch1_abv").oninput = calculateBlending;
                document.getElementById("batch1_volume").oninput = () => { updateBatch1VolumeDisplay(); calculateBlending(); };
                document.getElementById("batch1_volume_unit").onchange = () => { updateBatch1VolumeDisplay(); calculateBlending(); };
                document.getElementById("batch2_abv").oninput = calculateBlending;
                document.getElementById("batch2_volume").oninput = () => { updateBatch2VolumeDisplay(); calculateBlending(); };
                document.getElementById("batch2_volume_unit").onchange = () => { updateBatch2VolumeDisplay(); calculateBlending(); };
                blendingCalculatedOnce = true;
            }
        }
        // --- End of new functions ---


        // Initialize displays on page load
        window.onload = function() {
            loadTheme(); // Load theme preference
            // Set common volume options for all relevant dropdowns
            document.getElementById("volume_unit").innerHTML = commonVolumeOptions;
            document.getElementById("volume_unit_sg").innerHTML = commonVolumeOptions;
            document.getElementById("batch_volume_unit").innerHTML = commonVolumeOptions;
            document.getElementById("target_volume_unit").innerHTML = commonVolumeOptions;
            document.getElementById("prime_volume_unit").innerHTML = commonVolumeOptions;
            document.getElementById("current_volume_unit").innerHTML = commonVolumeOptions;
            document.getElementById("batch1_volume_unit").innerHTML = commonVolumeOptions;
            document.getElementById("batch2_volume_unit").innerHTML = commonVolumeOptions;
            document.getElementById("dilution_calorie_volume_unit").innerHTML = commonVolumeOptions;


            // Re-select default options after setting innerHTML
            document.getElementById("volume_unit").value = "ml";
            document.getElementById("volume_unit_sg").value = "ml";
            document.getElementById("batch_volume_unit").value = "liter";
            document.getElementById("target_volume_unit").value = "liter";
            document.getElementById("prime_volume_unit").value = "ml"; /* Set to mL */
            document.getElementById("current_volume_unit").value = "liter";
            document.getElementById("batch1_volume_unit").value = "ml"; /* Set to mL */
            document.getElementById("batch2_volume_unit").value = "ml"; /* Set to mL */
            document.getElementById("dilution_calorie_volume_unit").value = "ml";


            // Trigger initial unit displays for all sections
            updateVolumeDisplay();
            updateVolumeDisplaySG();
            updateSugarDisplay();
            updateBatchVolumeDisplay();
            updateTargetVolumeDisplay();
            updatePrimeVolumeDisplay();
            updateDilutionCurrentVolumeDisplay();
            updateDilutionCalorieVolumeDisplay();
            updateBatch1VolumeDisplay();
            updateBatch2VolumeDisplay();

            // Clear initial results to ensure they are empty until first click
            document.getElementById("output").innerHTML = '';
            document.getElementById("sg_output").innerHTML = '';
            document.getElementById("sugar_abv_output").innerHTML = '';
            document.getElementById("required_sugar_output").innerHTML = '';
            document.getElementById("priming_output").innerHTML = '';
            document.getElementById("dilution_output").innerHTML = '';
            document.getElementById("blending_output").innerHTML = '';
        };
</script>
</body>
</html>
